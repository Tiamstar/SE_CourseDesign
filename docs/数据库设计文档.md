# 基于大语言模型的软件工程课程助手 - 数据库设计文档

## 1. 数据库概述

### 1.1 设计目标

本系统的数据库设计旨在支持基于大语言模型的软件工程课程助手的数据存储需求，主要目标包括：

1. 高效存储和检索用户会话数据
2. 支持知识库的构建和检索
3. 确保系统的可扩展性和性能
4. 满足数据持久化和安全需求

### 1.2 数据库选型

#### 1.2.1 主数据库 - MongoDB

选择MongoDB作为主数据库基于以下考虑：

1. **文档模型**：MongoDB的文档模型非常适合存储会话数据和聊天记录等半结构化数据
2. **灵活性**：无需预定义模式，可以根据需求动态调整数据结构
3. **查询能力**：支持复杂查询和索引，满足会话检索需求
4. **可扩展性**：支持水平扩展，可应对用户量增长
5. **云服务支持**：华为云提供MongoDB服务，便于部署和管理

#### 1.2.2 检索引擎 - Elasticsearch

选择Elasticsearch作为知识库检索引擎基于以下考虑：

1. **全文检索**：强大的全文检索能力，支持复杂的检索需求
2. **相关性排序**：能基于相关度对检索结果进行排序
3. **分布式架构**：支持分布式部署，可扩展性强
4. **实时索引**：支持数据的实时索引和检索
5. **云服务支持**：华为云提供Elasticsearch服务

### 1.3 数据库架构

```
+----------------+        +----------------+
|                |        |                |
|    MongoDB     |        | Elasticsearch  |
|  (会话存储)     |        |  (知识库检索)   |
|                |        |                |
+-------+--------+        +-------+--------+
        ^                         ^
        |                         |
        |                         |
        v                         v
+----------------+----------------+
|                                 |
|          后端服务器               |
|         (Node.js)               |
|                                 |
+---------------------------------+
```

## 2. MongoDB数据设计

### 2.1 数据库和集合设计

MongoDB数据库名称：`smartse`

主要集合：

1. `chats`：存储用户聊天会话
2. `users`：存储用户信息（可选，用于未来扩展）
3. `feedback`：存储用户反馈（可选，用于未来扩展）

### 2.2 文档模型设计

#### 2.2.1 Chat文档模型

```javascript
{
  _id: ObjectId,           // 会话ID
  sessionId: String,       // 会话标识，用于前端区分会话
  agent: String,           // 智能体类型：general/concept/requirements/design/testing
  messages: [              // 消息数组
    {
      content: String,     // 消息内容
      sender: String,      // 发送者：user/assistant
      timestamp: Date      // 发送时间
    }
  ],
  createdAt: Date,         // 会话创建时间
  updatedAt: Date,         // 会话最后更新时间
  metadata: {              // 元数据，方便未来扩展
    clientInfo: String,    // 客户端信息
    ip: String,            // 用户IP（脱敏）
    referrer: String       // 引荐来源
  }
}
```

#### 2.2.2 User文档模型（可选，用于未来扩展）

```javascript
{
  _id: ObjectId,           // 用户ID
  userId: String,          // 用户唯一标识
  sessions: [String],      // 用户会话ID列表
  preferences: {           // 用户偏好设置
    preferredAgent: String,// 首选智能体
    theme: String          // 界面主题
  },
  createdAt: Date,         // 创建时间
  lastActive: Date         // 最后活跃时间
}
```

#### 2.2.3 Feedback文档模型（可选，用于未来扩展）

```javascript
{
  _id: ObjectId,           // 反馈ID
  sessionId: String,       // 关联的会话ID
  messageId: String,       // 关联的消息ID
  rating: Number,          // 评分（1-5）
  comment: String,         // 评论内容
  createdAt: Date          // 创建时间
}
```

### 2.3 索引设计

为提高查询效率，设计以下索引：

#### 2.3.1 Chats集合索引

```javascript
// 会话ID索引，用于快速查找特定会话
db.chats.createIndex({ "sessionId": 1 }, { unique: true });

// 智能体类型索引，用于按智能体类型筛选会话
db.chats.createIndex({ "agent": 1 });

// 时间索引，用于按时间排序和筛选
db.chats.createIndex({ "createdAt": 1 });
db.chats.createIndex({ "updatedAt": 1 });

// 复合索引，用于按智能体类型和时间查询
db.chats.createIndex({ "agent": 1, "updatedAt": -1 });
```

#### 2.3.2 其他集合索引（可选，用于未来扩展）

```javascript
// 用户集合索引
db.users.createIndex({ "userId": 1 }, { unique: true });
db.users.createIndex({ "lastActive": -1 });

// 反馈集合索引
db.feedback.createIndex({ "sessionId": 1 });
db.feedback.createIndex({ "rating": 1 });
```

### 2.4 数据操作示例

#### 2.4.1 创建新会话

```javascript
const newChat = {
  sessionId: "sess_" + generateUniqueId(),
  agent: "concept",
  messages: [],
  createdAt: new Date(),
  updatedAt: new Date(),
  metadata: {
    clientInfo: req.headers['user-agent'],
    ip: anonymizeIp(req.ip),
    referrer: req.headers['referer'] || ""
  }
};

await db.collection('chats').insertOne(newChat);
```

#### 2.4.2 添加新消息

```javascript
const message = {
  content: req.body.message,
  sender: "user",
  timestamp: new Date()
};

await db.collection('chats').updateOne(
  { sessionId: req.body.sessionId },
  { 
    $push: { messages: message },
    $set: { updatedAt: new Date() }
  }
);
```

#### 2.4.3 查询会话历史

```javascript
const chatHistory = await db.collection('chats').findOne(
  { sessionId: req.params.sessionId },
  { projection: { messages: 1, agent: 1 } }
);
```

## 3. Elasticsearch数据设计

### 3.1 索引设计

#### 3.1.1 知识库索引

索引名称：`smartse_knowledge`

索引映射：

```json
{
  "mappings": {
    "properties": {
      "title": { 
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "content": { 
        "type": "text", 
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "category": { 
        "type": "keyword" 
      },
      "tags": { 
        "type": "keyword" 
      },
      "source": { 
        "type": "keyword" 
      },
      "created_at": { 
        "type": "date" 
      }
    }
  },
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 1,
    "analysis": {
      "analyzer": {
        "ik_smart": {
          "type": "custom",
          "tokenizer": "ik_smart"
        },
        "ik_max_word": {
          "type": "custom",
          "tokenizer": "ik_max_word"
        }
      }
    }
  }
}
```

说明：
- `title`和`content`字段使用全文索引，以支持文本检索
- `category`和`tags`使用keyword类型，支持精确过滤和聚合
- 使用IK分词器处理中文分词

### 3.2 知识库数据模型

```json
{
  "title": "软件工程概述",
  "content": "软件工程是应用计算机科学理论和技术以及工程管理原则，以经济有效的方式获取高质量软件的一种工程学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。",
  "category": "concept",
  "tags": ["软件工程", "概述", "定义"],
  "source": "SE教材",
  "created_at": "2023-09-01T00:00:00Z"
}
```

### 3.3 初始数据导入

系统初始启动时，将预置的软件工程知识导入Elasticsearch：

```javascript
const seedKnowledgeBase = async () => {
  try {
    // 软件工程基本概念示例数据
    const knowledgeItems = [
      {
        title: "软件工程概述",
        content: "软件工程是应用计算机科学理论和技术以及工程管理原则，以经济有效的方式获取高质量软件的一种工程学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。",
        category: "concept",
        tags: ["软件工程", "概述", "定义"],
        source: "SE教材",
        created_at: new Date()
      },
      {
        title: "软件生命周期",
        content: "软件生命周期是软件从概念、需求分析、设计、编码、测试、运行维护直至废弃的整个过程。常见的生命周期模型包括瀑布模型、增量模型、螺旋模型和敏捷开发模型等。",
        category: "concept",
        tags: ["软件生命周期", "开发模型", "瀑布模型", "敏捷开发"],
        source: "SE教材",
        created_at: new Date()
      },
      // 更多知识条目...
    ];

    // 批量添加数据
    const bulkOps = knowledgeItems.flatMap(item => [
      { index: { _index: ES_INDEX } },
      item
    ]);

    await client.bulk({ body: bulkOps });
    console.log("知识库初始数据添加成功");
  } catch (error) {
    console.error("添加知识库数据失败:", error);
    throw error;
  }
};
```

### 3.4 检索查询示例

#### 3.4.1 基本检索

```javascript
const searchKnowledge = async (query, category = null) => {
  const searchBody = {
    query: {
      bool: {
        must: [
          {
            multi_match: {
              query: query,
              fields: ["title^2", "content"],
              fuzziness: "AUTO"
            }
          }
        ]
      }
    },
    highlight: {
      fields: {
        title: {},
        content: {}
      }
    }
  };
  
  // 如果指定了分类，添加过滤条件
  if (category) {
    searchBody.query.bool.filter = [
      { term: { category: category } }
    ];
  }
  
  return await client.search({
    index: ES_INDEX,
    body: searchBody
  });
};
```

#### 3.4.2 高级检索

```javascript
const advancedSearch = async (params) => {
  const { query, categories, tags, from, size } = params;
  
  const searchBody = {
    query: {
      bool: {
        must: [
          {
            multi_match: {
              query: query,
              fields: ["title^2", "content"],
              fuzziness: "AUTO"
            }
          }
        ],
        filter: []
      }
    },
    from: from || 0,
    size: size || 10,
    sort: [
      { _score: { order: "desc" } }
    ]
  };
  
  // 添加分类过滤
  if (categories && categories.length > 0) {
    searchBody.query.bool.filter.push({
      terms: { category: categories }
    });
  }
  
  // 添加标签过滤
  if (tags && tags.length > 0) {
    searchBody.query.bool.filter.push({
      terms: { tags: tags }
    });
  }
  
  return await client.search({
    index: ES_INDEX,
    body: searchBody
  });
};
```

## 4. 数据库安全设计

### 4.1 访问控制

#### 4.1.1 MongoDB访问控制

1. **身份验证**：启用MongoDB身份验证，使用用户名和密码访问
2. **角色分配**：创建只读和读写两种角色，按最小权限原则分配
3. **网络访问限制**：限制MongoDB只接受来自应用服务器的连接

```javascript
// 创建数据库管理员
db.createUser({
  user: "dbAdmin",
  pwd: "strongPassword",
  roles: [{ role: "dbOwner", db: "smartse" }]
})

// 创建应用程序用户(只有必要的权限)
db.createUser({
  user: "appUser",
  pwd: "appPassword",
  roles: [
    { role: "readWrite", db: "smartse" }
  ]
})
```

#### 4.1.2 Elasticsearch访问控制

1. **启用X-Pack安全**：使用X-Pack提供的安全功能
2. **SSL/TLS加密**：启用节点间和客户端与服务器间的加密通信
3. **角色分配**：创建应用程序专用角色，限制对索引的访问

```yaml
# elasticsearch.yml配置示例
xpack.security.enabled: true
xpack.security.transport.ssl.enabled: true
xpack.security.http.ssl.enabled: true
```

### 4.2 数据加密

1. **传输加密**：使用TLS/SSL加密数据传输
2. **敏感数据加密**：对用户IP等敏感信息进行脱敏或加密存储
3. **环境变量**：使用环境变量存储数据库连接信息，避免硬编码

### 4.3 备份与恢复策略

#### 4.3.1 MongoDB备份策略

1. **定时备份**：每日使用mongodump进行全量备份
2. **增量备份**：使用oplog进行增量备份
3. **备份验证**：定期验证备份的有效性
4. **异地备份**：将备份数据存储在不同地域的存储服务中

```bash
# MongoDB备份脚本示例
mongodump --uri="mongodb://appUser:appPassword@mongodb:27017/smartse" --out=/backup/mongo/$(date +%Y-%m-%d)
```

#### 4.3.2 Elasticsearch备份策略

1. **快照备份**：使用Elasticsearch快照功能进行索引备份
2. **定时执行**：设置定时任务，定期创建快照
3. **多仓库策略**：配置多个快照仓库，提高数据安全性

```
# Elasticsearch快照API示例
PUT /_snapshot/backup_repository/snapshot_1
```

## 5. 数据库性能优化

### 5.1 MongoDB性能优化

#### 5.1.1 索引优化

1. **覆盖索引**：设计索引覆盖常见查询，减少文档读取
2. **复合索引**：为常见的多字段查询创建复合索引
3. **索引监控**：定期检查索引使用情况，移除未使用的索引

#### 5.1.2 查询优化

1. **投影查询**：只检索需要的字段，减少网络传输
2. **批量操作**：使用批量插入和更新，减少操作次数
3. **分页查询**：实现有效的分页机制，限制返回结果数量

#### 5.1.3 架构优化

1. **分片**：随着数据量增长，考虑使用分片提高性能
2. **读写分离**：配置副本集，将读操作分发到从节点

### 5.2 Elasticsearch性能优化

#### 5.2.1 索引优化

1. **映射优化**：根据数据类型和用途优化字段映射
2. **分词器选择**：为中文内容选择合适的分词器
3. **字段权重**：设置字段权重，优化搜索相关性

#### 5.2.2 查询优化

1. **过滤与查询**：合理使用filter和query，提高检索效率
2. **聚合缓存**：对频繁使用的聚合查询启用缓存
3. **分页优化**：使用scroll API或search_after处理深度分页

#### 5.2.3 集群优化

1. **分片策略**：根据数据量合理设置分片数量
2. **副本配置**：为索引配置适当数量的副本，平衡可用性和性能
3. **资源分配**：合理分配内存，调整JVM参数

## 6. 监控与维护

### 6.1 MongoDB监控

1. **性能指标**：监控查询执行时间、连接数、内存使用等指标
2. **日志分析**：分析慢查询日志，识别性能瓶颈
3. **可视化工具**：使用MongoDB Compass或第三方工具进行可视化监控

### 6.2 Elasticsearch监控

1. **集群健康**：定期检查集群健康状态
2. **索引统计**：监控索引大小、文档数量和查询性能
3. **资源使用**：监控CPU、内存和磁盘使用情况

### 6.3 维护计划

1. **版本更新**：定期评估和实施数据库版本更新
2. **索引维护**：定期重建优化索引
3. **数据清理**：制定数据留存策略，定期清理过期数据

## 7. 数据迁移与扩展计划

### 7.1 数据迁移策略

1. **导出导入**：使用原生工具导出数据并导入新系统
2. **实时同步**：使用CDC (Change Data Capture) 工具实现实时数据同步
3. **蓝绿部署**：使用蓝绿部署策略进行无缝迁移

### 7.2 扩展计划

1. **垂直扩展**：随着用户量增长，增加服务器资源
2. **水平扩展**：实施分片策略，支持更大数据量
3. **功能扩展**：预留数据模型扩展字段，支持未来功能扩展 